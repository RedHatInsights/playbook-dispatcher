// Package private provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "playbook-dispatcher/internal/api/controllers/public"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Dispatch Playbooks
	// (POST /internal/dispatch)
	ApiInternalRunsCreate(ctx echo.Context) error
	// Cancel Playbook Runs
	// (POST /internal/v2/cancel)
	ApiInternalV2RunsCancel(ctx echo.Context) error
	// Obtain Connection Status of recipient(s) based on a list of host IDs
	// (POST /internal/v2/connection_status)
	ApiInternalHighlevelConnectionStatus(ctx echo.Context) error
	// Dispatch Playbooks
	// (POST /internal/v2/dispatch)
	ApiInternalV2RunsCreate(ctx echo.Context) error
	// Obtain connection status of recipient(s)
	// (POST /internal/v2/recipients/status)
	ApiInternalV2RecipientsStatus(ctx echo.Context) error
	// Get Version
	// (GET /internal/version)
	ApiInternalVersion(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApiInternalRunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalRunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalRunsCreate(ctx)
	return err
}

// ApiInternalV2RunsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCancel(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCancel(ctx)
	return err
}

// ApiInternalHighlevelConnectionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalHighlevelConnectionStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalHighlevelConnectionStatus(ctx)
	return err
}

// ApiInternalV2RunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCreate(ctx)
	return err
}

// ApiInternalV2RecipientsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RecipientsStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RecipientsStatus(ctx)
	return err
}

// ApiInternalVersion converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalVersion(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/internal/dispatch", wrapper.ApiInternalRunsCreate)
	router.POST(baseURL+"/internal/v2/cancel", wrapper.ApiInternalV2RunsCancel)
	router.POST(baseURL+"/internal/v2/connection_status", wrapper.ApiInternalHighlevelConnectionStatus)
	router.POST(baseURL+"/internal/v2/dispatch", wrapper.ApiInternalV2RunsCreate)
	router.POST(baseURL+"/internal/v2/recipients/status", wrapper.ApiInternalV2RecipientsStatus)
	router.GET(baseURL+"/internal/version", wrapper.ApiInternalVersion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./public.openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
