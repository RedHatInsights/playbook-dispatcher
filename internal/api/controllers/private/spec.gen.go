// Package private provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "playbook-dispatcher/internal/api/controllers/public"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Dispatch Playbooks
	// (POST /internal/dispatch)
	ApiInternalRunsCreate(ctx echo.Context) error
	// Cancel Playbook Runs
	// (POST /internal/v2/cancel)
	ApiInternalV2RunsCancel(ctx echo.Context) error
	// Obtain Connection Status of recipient(s) based on a list of host IDs
	// (POST /internal/v2/connection_status)
	ApiInternalHighlevelConnectionStatus(ctx echo.Context) error
	// Dispatch Playbooks
	// (POST /internal/v2/dispatch)
	ApiInternalV2RunsCreate(ctx echo.Context) error
	// Obtain connection status of recipient(s)
	// (POST /internal/v2/recipients/status)
	ApiInternalV2RecipientsStatus(ctx echo.Context) error
	// Get Version
	// (GET /internal/version)
	ApiInternalVersion(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApiInternalRunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalRunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalRunsCreate(ctx)
	return err
}

// ApiInternalV2RunsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCancel(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCancel(ctx)
	return err
}

// ApiInternalHighlevelConnectionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalHighlevelConnectionStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalHighlevelConnectionStatus(ctx)
	return err
}

// ApiInternalV2RunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCreate(ctx)
	return err
}

// ApiInternalV2RecipientsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RecipientsStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RecipientsStatus(ctx)
	return err
}

// ApiInternalVersion converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalVersion(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/internal/dispatch", wrapper.ApiInternalRunsCreate)
	router.POST(baseURL+"/internal/v2/cancel", wrapper.ApiInternalV2RunsCancel)
	router.POST(baseURL+"/internal/v2/connection_status", wrapper.ApiInternalHighlevelConnectionStatus)
	router.POST(baseURL+"/internal/v2/dispatch", wrapper.ApiInternalV2RunsCreate)
	router.POST(baseURL+"/internal/v2/recipients/status", wrapper.ApiInternalV2RecipientsStatus)
	router.GET(baseURL+"/internal/version", wrapper.ApiInternalVersion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RaWZPbNhL+KyjuPiRVOijNkVk9rTPOrlVrZ1y+8mC7pkCiKcIBARoANZ6k9N+3GuAp",
	"Ulc84/W+zUho9N39dUN/BrHKciVBWhMs/gw0mFxJA+6fnyl7BZ8LMBb/i5W0IN2fNM8Fj6nlSk4/GSXx",
	"MxOnkFH86+8akmAR/G3aXD3135rpL1orHWw2m1HAwMSa53hJsEBepGKG35YEeN81lTGIpcwL+26OH+Ra",
	"5aAt91Iqvbrl7BDjG71asmAzCnLNZcxzKg5RvKwPbkaBLuQRTPIiEjy+fVVI5IVk8LngGliweF9dMaoE",
	"bovycRTY+xyCRaCiTxBbZOlN1VM3A2PoCvDPrgWfFRmVRANlNBJAAMlJdXoUwBea5QJZvOCSZ0VGjNVc",
	"rogAubIp4YbMgloM/11Ph+q6IXmf8VX6HNYgXkHMcw7SvrbUFk5obiEzh6xX0/3GbXqtpIQYVVvKROH9",
	"JUOqNb13/JSxS9a3w5KBtDzhYAglGmKlGVEJsSkQJBkv5RqkVfqeGNBrHqNxMi6fOzMEi1nPBp6VQal8",
	"FPV8kuL3HT0fXaSMfll6ZhehO1z+N+sb6qQE2XJ4HatexSG/1zbZqTPqqfSKSv6HqxnEptS6T1d8DRiz",
	"RhU6BhKBUHJliFWB07A2QHjQHi/bad2V5K0BLWkGlckLA5pwaUHT2GIG3HGbum8a6zfZ8imlGk8ddkkd",
	"v9dKJnzVF0RXB8Ymh5gnPCaxO1pobxflThpXGtrxZagtPbjDxrrS7TW1IAS3QLg0Fgsn4dJrXXBG1ufT",
	"9QVJlM6o7WhJ6Vk0SygdX1wmZ+NzNjsfX80vrsaXsws2m8E8DC/DYBSUlAuUaMzZGC8NBkyBAjdhd0jo",
	"TmygM7hsFOmIOZufnV8c8sRmIEgHahIV4iYJFu9PKEo3GrXbzv7YlyoY0lUy7JNgyF0KNgVNKInryoY1",
	"F4ylkeAmBdbEYR0ojW0jpQRQ2UvQhnk/Nz+2FX/jvjuQpXgBeqUWgLyvHTEiT7mG2JLriuWI/KokfEQP",
	"ySJDaUzLa8ydLg8Ho0Aq6RrHsVk00AW+tvc3dj26kdfidOhvbWnNo0LHmb7MisPS1gb3MndT6SjCWl9T",
	"B/uusESnx4XW6GpdSOIpqsRsx2Hl4ibg0MWm/a9O41up7G1V1DpB2SoO96Zqk0fhgrLR9yDANr5qCVu3",
	"rS2P1T7o2LURqTbZx301pCoF/9twPKz+oBKF9HgaBnBMrNhAjShjAr9sAsMj9VZtnofzmh021xXoBwLO",
	"Tqr6pl1KaaD24XWaDel0qj6j3aDdgXzyYgClv5XwJXeZVUJ5Vji4nmsVgzEekexH6071HfZy41TfWjSO",
	"VXF0QD4pT29GDQTeWxFLvg5PI5WgEQhzJLfn/vAD1HHLM1DFCdRvSoLNKCi0OJLurRZ7s7Sytb9zn5+e",
	"VcbtBs+N+4MKcT8iXHpshrCCRqqwxHmEcLlWYg2sgoEvBb2PlPrdVfuYShIBhtSaM2CTD/JNyk3nLm4Q",
	"LzNiFck1jKkQCjsHkt8ihxq8m8kH+UJpUGvQI8JtdXlFHbsE7eKfCOwdgMShaPs6QiVzKqAGfjiafJDB",
	"qGkZW4ErDY8EuEsGZmO8yM0A1JDfpbqTKNITT9Ph8LYUl3tgdO+MVspRdUcNudLWeHmajEXLCMf/IMip",
	"OQ4j5Hoc5PWc6Cel8vaGZ5JE5z+F83BMLxM2Pr86Z+OrMLoYMxqG9JyehVEyb+P2YcA+hJi3p8gqFodW",
	"MN80+dGNRxJVwf4rkhw9CZfEX7sxejCsGdfj5FFos5w+v22ZGwV3EKGkRgm4PZ74N4iuPdGhajmwNfNS",
	"lhGxo36aNto5bg3VQkjDeWBaYOPoK0uSgRvbgP//Z8TfmjYeZczvMX0H2nC/b+5yK7+oWD15uexcuJ4f",
	"rslbmMaxyDXE3tNWFzA6qKIFSV20nra86tY47GaMcd/bX3YKbY+yK9CTmoxkYCmjlpZgYLv1T8h1qz0n",
	"SpOECwseYRY6VwbMJBhIqU5xPMLptUUaZ1ycza7m/wj/qpU6Rf3QFry998s7+r9tUI3B6bdpsu1zmFrw",
	"xYJGm5ZTIvmhjtofJx3N/sW/kGvNLY+pINfvfjFHR52fFPqrS8k/F1CBkdKstOPJw929zeRVuysd8p2D",
	"PVaRu5THKaGleWrm3BDKmAZj3PR/ghRvmsbEIKGFsMHi7DIMe/GcYSqiOAZiJZkhNLGgS4Hc0FY4iIqN",
	"hzPQGMuUC2CEFYCiVy3QxRrPiixYXIbnV6GPNv9BODTjtZpb3yuvnjvbYLK0E6tjBNeZdtmg2/YGGbgd",
	"ea64tMYp4tbTHjaX7rmDiJQdl9yloKHZbidcMpIpDQNzQT8V3qRAEg6CoSlVOVSQCGcIvkrFPTHFagXG",
	"Apv0Vdy/inVY12/uYiUtjZ3TIaNcBIvgk/oDkn9qYCm1k1hl/YpWB9tTbnJq4xS0i7tqVe9Kly6kRF9U",
	"eL4iMkTJcgyq11RkzSm5Fqpg1R5TaVfouHUpPMRwKcsC4NvKumpCwWwSTkIHLHOQNOfBIjibhJMzRCnU",
	"pq5kT3lJPWXljQ4/D44pNU/T0qHAWX9bZDceGas0oG7aP9syPIgZ4Z+YXAHH7uG8j+UleJLzSpkGxwQe",
	"dIGxPyt2f9JT77Hox28bTnm22ngs2HqNnoc/PdgzdBvEDTxG3/wHZT0Pw1331IJNW2/k7tm6yDKq71u+",
	"bDzpDjThsJ5PY4czd8eDx6FNMBCUezgg9rn63bwBwo/t7O5j/Xfm8RrWP47L/f1dbw04vd5/3Db7+WH/",
	"/1xwwQwR3NjOq8wP5kdXAHjvean9qNo+rIHQNeUCQdG+UHmGBR/WIJqXl/LF7K/HzaHdfutlfTAIwofj",
	"tusnCo8UEDeRpVySxpbkdf2+0vFPRBGNYouune3A1/LpQAB9X32kLC7ftJN8f5Vlfy85uTHUwWGmh2rE",
	"8sFrwLt5nR7mq5P/9F/++Ef2U/0ZPqJUVZHoy/GIRaO1JjeDRWM7aprVyArsoTffFbdEw5ob/3MctzEh",
	"d9SQqODCkkSrbH/Wl9wesVhXLI7JqX+DJZ3zOB6ANu7nHds/whHU8jUQROjlCnERTIPNx81/AwAA//8q",
	"Zo/jDSkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./public.openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
