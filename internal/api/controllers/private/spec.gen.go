// Package private provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package private

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	externalRef0 "playbook-dispatcher/internal/api/controllers/public"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Dispatch Playbooks
	// (POST /internal/dispatch)
	ApiInternalRunsCreate(ctx echo.Context) error
	// Cancel Playbook Runs
	// (POST /internal/v2/cancel)
	ApiInternalV2RunsCancel(ctx echo.Context) error
	// Obtain Connection Status of recipient(s) based on a list of host IDs
	// (POST /internal/v2/connection_status)
	ApiInternalHighlevelConnectionStatus(ctx echo.Context) error
	// Dispatch Playbooks
	// (POST /internal/v2/dispatch)
	ApiInternalV2RunsCreate(ctx echo.Context) error
	// Obtain connection status of recipient(s)
	// (POST /internal/v2/recipients/status)
	ApiInternalV2RecipientsStatus(ctx echo.Context) error
	// List hosts involved in Playbook runs
	// (GET /internal/v2/run_hosts)
	ApiInternalV2RunHostsList(ctx echo.Context, params ApiInternalV2RunHostsListParams) error
	// Get Version
	// (GET /internal/version)
	ApiInternalVersion(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApiInternalRunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalRunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalRunsCreate(ctx)
	return err
}

// ApiInternalV2RunsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCancel(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCancel(ctx)
	return err
}

// ApiInternalHighlevelConnectionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalHighlevelConnectionStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalHighlevelConnectionStatus(ctx)
	return err
}

// ApiInternalV2RunsCreate converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunsCreate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunsCreate(ctx)
	return err
}

// ApiInternalV2RecipientsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RecipientsStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RecipientsStatus(ctx)
	return err
}

// ApiInternalV2RunHostsList converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalV2RunHostsList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ApiInternalV2RunHostsListParams
	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalV2RunHostsList(ctx, params)
	return err
}

// ApiInternalVersion converts echo context to params.
func (w *ServerInterfaceWrapper) ApiInternalVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ApiInternalVersion(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/internal/dispatch", wrapper.ApiInternalRunsCreate)
	router.POST(baseURL+"/internal/v2/cancel", wrapper.ApiInternalV2RunsCancel)
	router.POST(baseURL+"/internal/v2/connection_status", wrapper.ApiInternalHighlevelConnectionStatus)
	router.POST(baseURL+"/internal/v2/dispatch", wrapper.ApiInternalV2RunsCreate)
	router.POST(baseURL+"/internal/v2/recipients/status", wrapper.ApiInternalV2RecipientsStatus)
	router.GET(baseURL+"/internal/v2/run_hosts", wrapper.ApiInternalV2RunHostsList)
	router.GET(baseURL+"/internal/version", wrapper.ApiInternalVersion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./public.openapi.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
