// Package public provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List hosts involved in Playbook runs
	// (GET /api/playbook-dispatcher/v1/run_hosts)
	ApiRunHostsList(ctx echo.Context, params ApiRunHostsListParams) error
	// List Playbook runs
	// (GET /api/playbook-dispatcher/v1/runs)
	ApiRunsList(ctx echo.Context, params ApiRunsListParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ApiRunHostsList converts echo context to params.
func (w *ServerInterfaceWrapper) ApiRunHostsList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ApiRunHostsListParams
	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApiRunHostsList(ctx, params)
	return err
}

// ApiRunsList converts echo context to params.
func (w *ServerInterfaceWrapper) ApiRunsList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ApiRunsListParams
	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("deepObject", true, false, "fields", ctx.QueryParams(), &params.Fields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields: %s", err))
	}

	// ------------- Optional query parameter "sort_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_by", ctx.QueryParams(), &params.SortBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort_by: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ApiRunsList(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/playbook-dispatcher/v1/run_hosts", wrapper.ApiRunHostsList)
	router.GET(baseURL+"/api/playbook-dispatcher/v1/runs", wrapper.ApiRunsList)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RZW2/jxhX+KwfTPnIlbTYNCj3Vdlo0qLMbaNdAgNTwjjiH0myGM/RcZKuG/ntxZihS",
	"FClTdtJg+2KY5Llfvxk9sdyUldGovWPzJ1Zxy0v0aOPTtSylp38EutzKykuj2Zz9yB9lGUrQoVyiBVOA",
	"RReUd+ANWPTBapYxSaT3Ae2WZUzzEtmcqSgwYy5fY8mT5IIH5dn8L7OMlUkwm38zoyep09PbjPltRfxS",
	"e1yhZbtdxj4UhcMB637QQubcowO/RnCeWy/1CirjJFGQufQhWgYWFfdyg2Q5vaVoKPQIDj1RSo8lCeIe",
	"Su7zdct6wkOTrBp08dCn2aBPi6D/aZz/h0QlXN+177GQGh0U8TvZvMQ64ChA6midRVcZ7XDyb8oCPlbK",
	"CGRzbwMOm5ykdUyurKnQeonJCO67jvzC1sZFJz33gVht0Ow2YzFcRIqanGzo6PMBtfPCBE8MdQyct1Kv",
	"2K55wa3l2xiS+oVZfsHcE4XzW0VvBGL1oXnbRE55tP3IXShlHhwUxkIRSagkltyhAKNhw600wUFuJX3i",
	"58Yt6jodN/J6/sR0UIovVSOrSyQF/S2MLblncxaCFKTiiKcXJ8WXqKKAP1ss2Jz9adp28jRZ5KaLoK8j",
	"4fu9PAog2o3McYz3YyJrOYeTEVM6JipSjUk6kVb39XdDTBnPcxN0rHbMZSUx/h+sYk22MuZliVT6TeSG",
	"muYZcbmxaWQZfRfJxuS36c5YbpF7FHc8GlaJ/cPv3Ifuq2rC39AobeBf06GvbbM/pqk+Gusvt/0c0Xsw",
	"VsSYDgXcGevvlttOxPeF2ymw9mHOXd59QToHym4Xg54aNvp/ycUC7wO6mILcaF9ng1eVoi0vjZ5+cSbO",
	"2dae58L2d2uNTaq6nl9yAXtl9LVmIHkXdS/2sYZA7WUhEwqieeNR89ipJX+8Rr3yazZ/mxZ/8zhQLFcp",
	"NhcDOi6Amtp5XlbwsMY01lB7u4UHTu0SOVnWVig19htiYgOakv+9NinROb6K1XqcFMrJfZAWBeV4T3g7",
	"UG7XTa9xISLa4uqn7vDcD82n3YBtR443MqBEz2nuAl+a4GMEflJ8uzTmV7BBT+CKa5r+gWZJd75UwVbG",
	"oZuwAYN/xDTLh80tuHKY9eBlijNByWRNs3KoFiLn8Y4/UT19/LwXFWcfJyiagPEAVDzMSZI/lJFFgiBd",
	"c3hbzs91yr7qd721Mz5Mr1qGH0SU0I6GEe62FXYZO0tZ0nDeoK9L9Hi6j2hYNLQvHuznD/RF0Gmmx/1b",
	"L/Jxnk815a6z00f4bhJlCjJhiDF6q4Y3TC/XvSq/0fI+IMh2VMYu9aY+UT0Y+yvYNHjhQfo1tCtgYEbU",
	"QL9f1ev6bVf7e15io7C2YQsciDpqkxoutJNLhSD1BrU3cdv19NZgfiQZr8x2fSDqWf8h+Cp4qKwRIUcB",
	"yy2NO01zbW90MwdN2gwruUEN9bmrP8qHEkjxdKeBboNPR9yJaelBx4yV9ZB9jj0O4uOxFg2o+U8Mt/MK",
	"zhTAOwvjcFvWeG6o0I4g4TN7rcd9Ah52jF8cTqAxYBEL1ht4WMt8DbzOc+OUdMCFsOhcFws8493Hpk67",
	"uq+Ctag9pDoeDN4e8NXFSGAw5Dk66tiCSxUsHhxGbof1f2pHXAML3n03m/VwQElriOxwmBstHPDCo60j",
	"EQ95QVMAcqOdFGgJA3CpUIAI6WanORU1N0zfzb7962zkQiYh5d/eGH9oU3xst9MRsk8f0mWWt3K1ipFq",
	"Z8ZRjkcQ6/G5hTBkh2P0gHR0gDk4R5xdVqM62j33UlytuPNQL9SzwfVN2qRH82hxHbuXpvYhcu20aTzG",
	"DxyHpC7M/uzD8+gGllwqNmdfzH+w+JtFseZ+kpuyj6CbjH4vXUXLFm0cFFBDmAiVTy0URxuF7I6NpTH3",
	"KGAjOVwpEwRcpXfGRmAtfTxnDihkGdugdcmg2WQ2eUt2mgo1rySbs3eT2eQdIWbu17GZpryS06oW9EY0",
	"gqabt1Mb9N16v61WQ7e/i4igyUclXRwaqTUIW1cWHY1Vvar9knpj1CZdFh1Wv5vAjVboiImSEV0PjhjT",
	"wcLt75ZMsDk6cJVFLoDn1jgHZVBeVgqPZb43UKJdkRhjQaAIzSGW0lKhpXpIa96vpWsUwBuQE5yALPbI",
	"5WdiODS/OlQFF8C1gEuyUoN/MODCsrU2gix8lM5nYDR2I/NzWxBRCBFQmVymGzSagw3UYxeV3OOHaxkR",
	"x+EPCL8Mj7eWZNq9td1l5zPES7ozGNJPGGcQ1j8n7G6PriC+mc1+t7uHBmsNXD98+Bf1xbdJ25CQxqrp",
	"wa1IvKgIZcntls0Z5WCstCPLSI+9pL06wmOltBulPmhO4NMaE0Oezumpi5qmIo7P6d1naHKS2Orb3f69",
	"bl2zqX1quZQla5SKhwyS/DmxH0o9WcavLmH3ovp15xfvwUXd/2Gp/2/L/Liod7v/BgAA//9x2chKzBwA",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
