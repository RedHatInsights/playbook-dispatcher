// Package rbac provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.6.0 DO NOT EDIT.
package rbac

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Basic_authScopes = "basic_auth.Scopes"
)

// Defines values for ResourceDefinitionFilterOperationEqualOperation.
const (
	Equal ResourceDefinitionFilterOperationEqualOperation = "equal"
)

// Valid indicates whether the value is a known member of the ResourceDefinitionFilterOperationEqualOperation enum.
func (e ResourceDefinitionFilterOperationEqualOperation) Valid() bool {
	switch e {
	case Equal:
		return true
	default:
		return false
	}
}

// Defines values for ResourceDefinitionFilterOperationInOperation.
const (
	In ResourceDefinitionFilterOperationInOperation = "in"
)

// Valid indicates whether the value is a known member of the ResourceDefinitionFilterOperationInOperation enum.
func (e ResourceDefinitionFilterOperationInOperation) Valid() bool {
	switch e {
	case In:
		return true
	default:
		return false
	}
}

// Defines values for GetPrincipalAccessParamsOrderBy.
const (
	Application  GetPrincipalAccessParamsOrderBy = "application"
	ResourceType GetPrincipalAccessParamsOrderBy = "resource_type"
	Verb         GetPrincipalAccessParamsOrderBy = "verb"
)

// Valid indicates whether the value is a known member of the GetPrincipalAccessParamsOrderBy enum.
func (e GetPrincipalAccessParamsOrderBy) Valid() bool {
	switch e {
	case Application:
		return true
	case ResourceType:
		return true
	case Verb:
		return true
	default:
		return false
	}
}

// Defines values for GetPrincipalAccessParamsStatus.
const (
	All      GetPrincipalAccessParamsStatus = "all"
	Disabled GetPrincipalAccessParamsStatus = "disabled"
	Enabled  GetPrincipalAccessParamsStatus = "enabled"
)

// Valid indicates whether the value is a known member of the GetPrincipalAccessParamsStatus enum.
func (e GetPrincipalAccessParamsStatus) Valid() bool {
	switch e {
	case All:
		return true
	case Disabled:
		return true
	case Enabled:
		return true
	default:
		return false
	}
}

// Access defines model for Access.
type Access struct {
	Permission          string               `json:"permission"`
	ResourceDefinitions []ResourceDefinition `json:"resourceDefinitions"`
}

// AccessPagination defines model for AccessPagination.
type AccessPagination struct {
	Data  []Access         `json:"data"`
	Links *PaginationLinks `json:"links,omitempty"`
	Meta  *PaginationMeta  `json:"meta,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Errors []struct {
		Detail *string `json:"detail,omitempty"`
		Status *string `json:"status,omitempty"`
	} `json:"errors"`
}

// ListPagination defines model for ListPagination.
type ListPagination struct {
	Links *PaginationLinks `json:"links,omitempty"`
	Meta  *PaginationMeta  `json:"meta,omitempty"`
}

// PaginationLinks defines model for PaginationLinks.
type PaginationLinks struct {
	First    *string `json:"first,omitempty"`
	Last     *string `json:"last,omitempty"`
	Next     *string `json:"next,omitempty"`
	Previous *string `json:"previous,omitempty"`
}

// PaginationMeta defines model for PaginationMeta.
type PaginationMeta struct {
	Count *int64 `json:"count,omitempty"`
}

// ResourceDefinition defines model for ResourceDefinition.
type ResourceDefinition struct {
	AttributeFilter ResourceDefinitionFilter `json:"attributeFilter"`
}

// ResourceDefinitionFilter defines model for ResourceDefinitionFilter.
type ResourceDefinitionFilter struct {
	union json.RawMessage
}

// ResourceDefinitionFilterOperationEqual defines model for ResourceDefinitionFilterOperationEqual.
type ResourceDefinitionFilterOperationEqual struct {
	Key       string                                          `json:"key"`
	Operation ResourceDefinitionFilterOperationEqualOperation `json:"operation"`
	Value     *string                                         `json:"value"`
}

// ResourceDefinitionFilterOperationEqualOperation defines model for ResourceDefinitionFilterOperationEqual.Operation.
type ResourceDefinitionFilterOperationEqualOperation string

// ResourceDefinitionFilterOperationIn defines model for ResourceDefinitionFilterOperationIn.
type ResourceDefinitionFilterOperationIn struct {
	Key       string                                       `json:"key"`
	Operation ResourceDefinitionFilterOperationInOperation `json:"operation"`
	Value     []*string                                    `json:"value"`
}

// ResourceDefinitionFilterOperationInOperation defines model for ResourceDefinitionFilterOperationIn.Operation.
type ResourceDefinitionFilterOperationInOperation string

// QueryLimit defines model for QueryLimit.
type QueryLimit = int

// QueryOffset defines model for QueryOffset.
type QueryOffset = int

// GetPrincipalAccessParams defines parameters for GetPrincipalAccess.
type GetPrincipalAccessParams struct {
	// Application The application name(s) to obtain access for the principal. This is an exact match. When no application is supplied, all permissions for the principal are returned. You may also use a comma-separated list to match on multiple applications.
	Application string `form:"application" json:"application"`

	// Username Unique username of the principal to obtain access for (only available for admins, and if supplied, takes precedence over the identity header).
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// OrderBy Parameter for ordering roles by value. For inverse ordering, supply '-' before the param value, such as: ?order_by=-application
	OrderBy *GetPrincipalAccessParamsOrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Status Set the status of users to get back.
	Status *GetPrincipalAccessParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Limit Parameter for selecting the amount of data returned.
	Limit *QueryLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Parameter for selecting the offset of data.
	Offset *QueryOffset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPrincipalAccessParamsOrderBy defines parameters for GetPrincipalAccess.
type GetPrincipalAccessParamsOrderBy string

// GetPrincipalAccessParamsStatus defines parameters for GetPrincipalAccess.
type GetPrincipalAccessParamsStatus string

// AsResourceDefinitionFilterOperationEqual returns the union data inside the ResourceDefinitionFilter as a ResourceDefinitionFilterOperationEqual
func (t ResourceDefinitionFilter) AsResourceDefinitionFilterOperationEqual() (ResourceDefinitionFilterOperationEqual, error) {
	var body ResourceDefinitionFilterOperationEqual
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResourceDefinitionFilterOperationEqual overwrites any union data inside the ResourceDefinitionFilter as the provided ResourceDefinitionFilterOperationEqual
func (t *ResourceDefinitionFilter) FromResourceDefinitionFilterOperationEqual(v ResourceDefinitionFilterOperationEqual) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResourceDefinitionFilterOperationEqual performs a merge with any union data inside the ResourceDefinitionFilter, using the provided ResourceDefinitionFilterOperationEqual
func (t *ResourceDefinitionFilter) MergeResourceDefinitionFilterOperationEqual(v ResourceDefinitionFilterOperationEqual) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResourceDefinitionFilterOperationIn returns the union data inside the ResourceDefinitionFilter as a ResourceDefinitionFilterOperationIn
func (t ResourceDefinitionFilter) AsResourceDefinitionFilterOperationIn() (ResourceDefinitionFilterOperationIn, error) {
	var body ResourceDefinitionFilterOperationIn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResourceDefinitionFilterOperationIn overwrites any union data inside the ResourceDefinitionFilter as the provided ResourceDefinitionFilterOperationIn
func (t *ResourceDefinitionFilter) FromResourceDefinitionFilterOperationIn(v ResourceDefinitionFilterOperationIn) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResourceDefinitionFilterOperationIn performs a merge with any union data inside the ResourceDefinitionFilter, using the provided ResourceDefinitionFilterOperationIn
func (t *ResourceDefinitionFilter) MergeResourceDefinitionFilterOperationIn(v ResourceDefinitionFilterOperationIn) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResourceDefinitionFilter) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResourceDefinitionFilter) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPrincipalAccess request
	GetPrincipalAccess(ctx context.Context, params *GetPrincipalAccessParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPrincipalAccess(ctx context.Context, params *GetPrincipalAccessParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPrincipalAccessRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPrincipalAccessRequest generates requests for GetPrincipalAccess
func NewGetPrincipalAccessRequest(server string, params *GetPrincipalAccessParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithOptions("form", true, "application", params.Application, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "string", Format: ""}); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithOptions("form", true, "username", *params.Username, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "string", Format: ""}); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithOptions("form", true, "order_by", *params.OrderBy, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "string", Format: ""}); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithOptions("form", true, "status", *params.Status, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "string", Format: ""}); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithOptions("form", true, "limit", *params.Limit, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "integer", Format: ""}); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithOptions("form", true, "offset", *params.Offset, runtime.StyleParamOptions{ParamLocation: runtime.ParamLocationQuery, Type: "integer", Format: ""}); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPrincipalAccessWithResponse request
	GetPrincipalAccessWithResponse(ctx context.Context, params *GetPrincipalAccessParams, reqEditors ...RequestEditorFn) (*GetPrincipalAccessResponse, error)
}

type GetPrincipalAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessPagination
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetPrincipalAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPrincipalAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPrincipalAccessWithResponse request returning *GetPrincipalAccessResponse
func (c *ClientWithResponses) GetPrincipalAccessWithResponse(ctx context.Context, params *GetPrincipalAccessParams, reqEditors ...RequestEditorFn) (*GetPrincipalAccessResponse, error) {
	rsp, err := c.GetPrincipalAccess(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPrincipalAccessResponse(rsp)
}

// ParseGetPrincipalAccessResponse parses an HTTP response from a GetPrincipalAccessWithResponse call
func ParseGetPrincipalAccessResponse(rsp *http.Response) (*GetPrincipalAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPrincipalAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessPagination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
