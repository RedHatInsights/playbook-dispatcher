package utils

import (
	"context"
	"errors"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs/types"
)

// CloudWatchClient is an interface for CloudWatch Logs operations
type CloudWatchClient interface {
	CreateLogStream(ctx context.Context, params *cloudwatchlogs.CreateLogStreamInput, optFns ...func(*cloudwatchlogs.Options)) (*cloudwatchlogs.CreateLogStreamOutput, error)
	PutLogEvents(ctx context.Context, params *cloudwatchlogs.PutLogEventsInput, optFns ...func(*cloudwatchlogs.Options)) (*cloudwatchlogs.PutLogEventsOutput, error)
}

// CloudWatchWriter is a custom io.Writer that writes logs to AWS CloudWatch Logs.
// generated by Claude Code
type CloudWatchWriter struct {
	client        *cloudwatchlogs.Client
	mockClient    CloudWatchClient // Used for testing only
	logGroupName  string
	logStreamName string
	sequenceToken *string
	buffer        []types.InputLogEvent
	bufferMutex   sync.Mutex
	flushInterval time.Duration
	maxBufferSize int
	done          chan struct{}
}

// NewCloudWatchWriter creates a new CloudWatchWriter that writes logs to AWS CloudWatch Logs.
// It creates the log stream if it doesn't exist and starts a background flusher.
func NewCloudWatchWriter(client *cloudwatchlogs.Client, logGroupName, logStreamName string) (*CloudWatchWriter, error) {
	writer := &CloudWatchWriter{
		client:        client,
		logGroupName:  logGroupName,
		logStreamName: logStreamName,
		buffer:        make([]types.InputLogEvent, 0),
		flushInterval: 5 * time.Second,
		maxBufferSize: 100,
		done:          make(chan struct{}),
	}

	// Create log stream if it doesn't exist
	_, err := client.CreateLogStream(context.Background(), &cloudwatchlogs.CreateLogStreamInput{
		LogGroupName:  aws.String(logGroupName),
		LogStreamName: aws.String(logStreamName),
	})
	// Ignore ResourceAlreadyExistsException - stream may already exist
	if err != nil {
		var resourceAlreadyExists *types.ResourceAlreadyExistsException
		if !errors.As(err, &resourceAlreadyExists) {
			return nil, err
		}
	}

	// Start background flusher
	go writer.backgroundFlusher()

	return writer, nil
}

func (w *CloudWatchWriter) Write(p []byte) (n int, err error) {
	w.bufferMutex.Lock()
	defer w.bufferMutex.Unlock()

	logEvent := types.InputLogEvent{
		Message:   aws.String(string(p)),
		Timestamp: aws.Int64(time.Now().UnixNano() / int64(time.Millisecond)),
	}

	w.buffer = append(w.buffer, logEvent)

	if len(w.buffer) >= w.maxBufferSize {
		go w.flush()
	}

	return len(p), nil
}

func (w *CloudWatchWriter) backgroundFlusher() {
	ticker := time.NewTicker(w.flushInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			w.flush()
		case <-w.done:
			w.flush() // Final flush before closing
			return
		}
	}
}

func (w *CloudWatchWriter) flush() error {
	if w.mockClient != nil {
		return w.flushWithClient(w.mockClient)
	}
	return w.flushWithClient(w.client)
}

func (w *CloudWatchWriter) flushWithClient(client CloudWatchClient) error {
	w.bufferMutex.Lock()
	defer w.bufferMutex.Unlock()

	if len(w.buffer) == 0 {
		return nil
	}

	input := &cloudwatchlogs.PutLogEventsInput{
		LogGroupName:  aws.String(w.logGroupName),
		LogStreamName: aws.String(w.logStreamName),
		LogEvents:     w.buffer,
		SequenceToken: w.sequenceToken,
	}

	resp, err := client.PutLogEvents(context.Background(), input)
	if err != nil {
		return err
	}

	w.sequenceToken = resp.NextSequenceToken
	w.buffer = make([]types.InputLogEvent, 0)

	return nil
}

// Close stops the background flusher and flushes any remaining buffered events.
func (w *CloudWatchWriter) Close() error {
	if w.mockClient != nil {
		return w.closeWithClient(w.mockClient)
	}
	return w.closeWithClient(w.client)
}

func (w *CloudWatchWriter) closeWithClient(client CloudWatchClient) error {
	close(w.done)
	return w.flushWithClient(client)
}
